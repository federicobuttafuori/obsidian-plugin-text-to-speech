/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ListenUp
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_child_process = require("child_process");

// utils/removeFormatting.ts
function removeAllFormatting(md, options) {
  options = options || {};
  options.listUnicodeChar = options.hasOwnProperty("listUnicodeChar") ? options.listUnicodeChar : false;
  options.stripListLeaders = options.hasOwnProperty("stripListLeaders") ? options.stripListLeaders : true;
  options.gfm = options.hasOwnProperty("gfm") ? options.gfm : true;
  options.useImgAltText = options.hasOwnProperty("useImgAltText") ? options.useImgAltText : true;
  options.abbr = options.hasOwnProperty("abbr") ? options.abbr : false;
  options.replaceLinksWithURL = options.hasOwnProperty("replaceLinksWithURL") ? options.replaceLinksWithURL : false;
  options.htmlTagsToSkip = options.hasOwnProperty("htmlTagsToSkip") ? options.htmlTagsToSkip : [];
  let output = md || "";
  output = output.replace(/^(-\s*?|\*\s*?|_\s*?){3,}\s*/gm, "");
  try {
    if (options.stripListLeaders) {
      if (options.listUnicodeChar)
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, options.listUnicodeChar + " $1");
      else
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, "$1");
    }
    if (options.gfm) {
      output = output.replace(/\n={2,}/g, "\n").replace(/~{3}.*\n/g, "").replace(/~~/g, "").replace(/`{3}.*\n/g, "");
    }
    if (options.abbr) {
      output = output.replace(/\*\[.*\]:.*\n/, "");
    }
    output = output.replace(/<[^>]*>/g, "");
    let htmlReplaceRegex = new RegExp("<[^>]*>", "g");
    if (options.htmlTagsToSkip.length > 0) {
      const joinedHtmlTagsToSkip = "(?!" + options.htmlTagsToSkip.join("|") + ")";
      htmlReplaceRegex = new RegExp(
        "<" + joinedHtmlTagsToSkip + "[^>]*>",
        "ig"
      );
    }
    output = output.replace(htmlReplaceRegex, "").replace(/^[=\-]{2,}\s*$/g, "").replace(/\[\^.+?\](\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "").replace(/\!\[(.*?)\][\[\(].*?[\]\)]/g, options.useImgAltText ? "$1" : "").replace(/\[([^\]]*?)\][\[\(].*?[\]\)]/g, options.replaceLinksWithURL ? "$2" : "$1").replace(/^(\n)?\s{0,3}>\s?/gm, "$1").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "").replace(/^(\n)?\s{0,}#{1,6}\s*( (.+))? +#+$|^(\n)?\s{0,}#{1,6}\s*( (.+))?$/gm, "$1$3$4$6").replace(/([\*]+)(\S)(.*?\S)??\1/g, "$2$3").replace(/(^|\W)([_]+)(\S)(.*?\S)??\2($|\W)/g, "$1$3$4$5").replace(/(`{3,})(.*?)\1/gm, "$2").replace(/`(.+?)`/g, "$1").replace(/~(.*?)~/g, "$1");
  } catch (e) {
    console.error(e);
    return md;
  }
  return output;
}

// utils/utils.ts
var import_obsidian = require("obsidian");
function getBasePath() {
  let adapter = this.app.vault.adapter;
  if (adapter instanceof import_obsidian.FileSystemAdapter) {
    return adapter.getBasePath();
  }
  return "~/";
}

// Settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  customModelFilePath: "",
  customModelConfigFilePath: "",
  piperExecutableFilePath: "",
  shouldUseCustomModel: true
};
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.addSettingToSelectPiperExecutablePath(containerEl);
    this.addSettingToSelectModelFilePath(containerEl);
    this.addSettingToSelectModelConfigFilePath(containerEl);
  }
  addSettingToSelectModelFilePath(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Select custom model file").setDesc(`File that ends with .onnx`).addText((component) => {
      component.setDisabled(true);
      component.setValue(this.plugin.settings.customModelFilePath);
    }).addExtraButton((component) => {
      component.setIcon("folder-open");
      component.setTooltip("Select model");
      component.onClick(() => {
        electron.remote.dialog.showOpenDialog({
          properties: ["openFile"],
          title: "Select a model"
        }).then((result) => {
          if (result.canceled)
            return;
          this.plugin.settings.customModelFilePath = result.filePaths[0];
          this.plugin.saveSettings();
          this.display();
        });
      });
    });
  }
  addSettingToSelectModelConfigFilePath(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Select model config file").setDesc(`File that ends with .json`).addText((component) => {
      component.setDisabled(true);
      component.setValue(this.plugin.settings.customModelConfigFilePath);
    }).addExtraButton((component) => {
      component.setIcon("folder-open");
      component.setTooltip("Select model config");
      component.onClick(() => {
        electron.remote.dialog.showOpenDialog({
          properties: ["openFile"],
          title: "Select a model config"
        }).then((result) => {
          if (result.canceled)
            return;
          this.plugin.settings.customModelConfigFilePath = result.filePaths[0];
          this.plugin.saveSettings();
          this.display();
        });
      });
    });
  }
  addSettingsToChooseWhetherToUseCustomModelOrDefault(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Use custom model?").setDesc(`Turn this on if you want to use different voice model. Check this doc to understand more: DOC LINK`).addToggle((component) => {
      component.setValue(this.plugin.settings.shouldUseCustomModel);
      component.onChange((value) => {
        this.plugin.settings.shouldUseCustomModel = value;
        this.plugin.saveSettings();
        this.display();
      });
    });
  }
  addSettingToSelectPiperExecutablePath(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Select Piper executable file").setDesc(`This is required`).addText((component) => {
      component.setDisabled(true);
      component.setValue(this.plugin.settings.piperExecutableFilePath);
    }).addExtraButton((component) => {
      component.setIcon("folder-open");
      component.setTooltip("Select piper executable");
      component.onClick(() => {
        electron.remote.dialog.showOpenDialog({
          properties: ["openFile"],
          title: "Select piper executable"
        }).then((result) => {
          if (result.canceled)
            return;
          this.plugin.settings.piperExecutableFilePath = result.filePaths[0];
          this.plugin.saveSettings();
          this.display();
        });
      });
    });
  }
};

// main.ts
var ListenUp = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.addCommand({
      id: "convert-text-to-speech",
      name: "Convert text to speech",
      editorCallback: async (editor, _) => {
        const notice = new import_obsidian3.Notice(
          "Converting the text to natural speech, please wait..",
          0
        );
        const basePath = getBasePath();
        const currentFile = this.app.workspace.getActiveFile();
        const audioFileName = (
          // @ts-ignore
          (currentFile == null ? void 0 : currentFile.name.replaceAll(" ", "-")) + "-" + this.getRandomNumber() + ".wav"
        );
        const piperLocation = (0, import_obsidian3.normalizePath)(this.settings.piperExecutableFilePath);
        let modelPath = (0, import_obsidian3.normalizePath)(basePath + "/" + DEFAULT_SETTINGS.customModelFilePath);
        let modelConfigPath = (0, import_obsidian3.normalizePath)(basePath + "/" + DEFAULT_SETTINGS.customModelConfigFilePath);
        const outputFilePath = (0, import_obsidian3.normalizePath)(basePath + "/" + audioFileName);
        modelPath = (0, import_obsidian3.normalizePath)(this.settings.customModelFilePath);
        modelConfigPath = (0, import_obsidian3.normalizePath)(this.settings.customModelConfigFilePath);
        const piperCommand = `"${piperLocation}" --model "${modelPath}" --config "${modelConfigPath}" --output_file "${outputFilePath}" --sentence_silence 0.5 --length_scale 1`;
        let textToConvertToAudio = editor.getValue();
        const regExMatch = textToConvertToAudio.match(
          /{{listen}}([\s\S]*?){{\/listen}}/g
        );
        const userSelection = editor.getSelection();
        if (regExMatch !== null) {
          textToConvertToAudio = regExMatch.join(", ").replaceAll(/{{listen}}|{{\/listen}}/g, "");
        } else if (userSelection.length) {
          textToConvertToAudio = userSelection;
        }
        textToConvertToAudio = removeAllFormatting(
          textToConvertToAudio != null ? textToConvertToAudio : " ",
          {}
          // @ts-ignore
        ).replaceAll('"', '\\"');
        (0, import_child_process.exec)(
          `echo "${textToConvertToAudio}" | ${piperCommand}`,
          async (error) => {
            if (error) {
              console.error(`

error: ${error.message}`);
              notice.setMessage("Something went wrong. Please raise an issue on Github or Discord");
              return;
            }
            const markdownLink = `![[${audioFileName}]]`;
            const userSelection = editor.getSelection(); // Get the currently selected text
            const cursorStart = editor.getCursor("from"); // Get the start position of the selection
            const cursorEnd = editor.getCursor("to"); // Get the end position of the selection

            // If there's a selection, insert the link immediately after the selection.
            // If there's no selection (just a cursor), insert it at the cursor position.
            editor.replaceRange(
                markdownLink,
                cursorEnd // Insert at the end of the selection or cursor position
            );

            // If text was selected, adjust the cursor back to the end of the original selection
            // so the user can continue typing there, and the newly inserted link doesn't move it.
            if (userSelection.length > 0) {
                editor.setCursor({ line: cursorEnd.line, ch: cursorEnd.ch + markdownLink.length });
            }

            setTimeout(() => {
              notice.hide();
            }, 200);
          }
        );
      }
    });
  }
  async onunload() {
  }
  getRandomNumber(min = 1e4, max = 99999) {
    return Math.floor(Math.random() * (max - min) + min);
  }
  async loadSettings() {
    const data = await this.loadData() || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
  }
  /**
   * Save data to disk, stored in data.json in plugin folder
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
};


/* nosourcemap */