/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ListenUp
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_child_process = require("child_process");
var import_fs = require("fs");
var import_os = require("os");

// utils/removeFormatting.ts
function removeAllFormatting(md, options) {
  options = options || {};
  options.listUnicodeChar = options.hasOwnProperty("listUnicodeChar") ? options.listUnicodeChar : false;
  options.stripListLeaders = options.hasOwnProperty("stripListLeaders") ? options.stripListLeaders : true;
  options.gfm = options.hasOwnProperty("gfm") ? options.gfm : true;
  options.useImgAltText = options.hasOwnProperty("useImgAltText") ? options.useImgAltText : true;
  options.abbr = options.hasOwnProperty("abbr") ? options.abbr : false;
  options.replaceLinksWithURL = options.hasOwnProperty("replaceLinksWithURL") ? options.replaceLinksWithURL : false;
  options.htmlTagsToSkip = options.hasOwnProperty("htmlTagsToSkip") ? options.htmlTagsToSkip : [];
  
  // New options for extended formatting removal
  options.removeHighlights = options.hasOwnProperty("removeHighlights") ? options.removeHighlights : true;
  options.removeInserts = options.hasOwnProperty("removeInserts") ? options.removeInserts : true;
  options.removeComments = options.hasOwnProperty("removeComments") ? options.removeComments : true;
  options.removeAngleBrackets = options.hasOwnProperty("removeAngleBrackets") ? options.removeAngleBrackets : true;
  options.removeParentheses = options.hasOwnProperty("removeParentheses") ? options.removeParentheses : true;
  options.removeCurlyBraces = options.hasOwnProperty("removeCurlyBraces") ? options.removeCurlyBraces : true;
  options.customWrappers = options.hasOwnProperty("customWrappers") ? options.customWrappers : [];
  options.customRegexPattern = options.hasOwnProperty("customRegexPattern") ? options.customRegexPattern : "";

  let output = md || "";
  output = output.replace(/^(-\s*?|\*\s*?|_\s*?){3,}\s*/gm, "");
  
  try {
    if (options.stripListLeaders) {
      if (options.listUnicodeChar)
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, options.listUnicodeChar + " $1");
      else
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, "$1");
    }
    if (options.gfm) {
      output = output.replace(/\n={2,}/g, "\n").replace(/~{3}.*\n/g, "").replace(/~~/g, "").replace(/`{3}.*\n/g, "");
    }
    if (options.abbr) {
      output = output.replace(/\*\[.*\]:.*\n/, "");
    }
    
    // Enhanced formatting removal rules
    
    // Remove highlights ==text==
    if (options.removeHighlights) {
      output = output.replace(/==(.*?)==/g, "$1");
    }
    
    // Remove inserts ++text++
    if (options.removeInserts) {
      output = output.replace(/\+\+(.*?)\+\+/g, "$1");
    }
    
    // Remove comments %%text%%
    if (options.removeComments) {
      output = output.replace(/%%.*?%%/g, "");
    }
    
    // Remove angle brackets <<text>>
    if (options.removeAngleBrackets) {
      output = output.replace(/<<(.*?)>>/g, "$1");
    }
    
    // Remove double parentheses ((text))
    if (options.removeParentheses) {
      output = output.replace(/\(\((.*?)\)\)/g, "$1");
    }
    
    // Remove curly braces {{text}} (but not the listen tags)
    if (options.removeCurlyBraces) {
      output = output.replace(/{{(?!listen|\/listen)(.*?)}}/g, "$1");
    }
    
    // Handle custom wrappers
    if (options.customWrappers && Array.isArray(options.customWrappers)) {
      for (const wrapper of options.customWrappers) {
        if (wrapper.trim()) {
          try {
            // Escape special regex characters in the wrapper
            const escapedWrapper = wrapper.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`${escapedWrapper}(.*?)${escapedWrapper}`, 'g');
            output = output.replace(regex, "$1");
          } catch (e) {
            console.warn(`Invalid custom wrapper: ${wrapper}`, e);
          }
        }
      }
    }
    
    // Handle custom regex pattern
    if (options.customRegexPattern && options.customRegexPattern.trim()) {
      try {
        const customRegex = new RegExp(options.customRegexPattern, 'g');
        output = output.replace(customRegex, "");
      } catch (e) {
        console.warn(`Invalid custom regex pattern: ${options.customRegexPattern}`, e);
      }
    }
    
    output = output.replace(/<[^>]*>/g, "");
    let htmlReplaceRegex = new RegExp("<[^>]*>", "g");
    if (options.htmlTagsToSkip.length > 0) {
      const joinedHtmlTagsToSkip = "(?!" + options.htmlTagsToSkip.join("|") + ")";
      htmlReplaceRegex = new RegExp(
        "<" + joinedHtmlTagsToSkip + "[^>]*>",
        "ig"
      );
    }
    output = output.replace(htmlReplaceRegex, "").replace(/^[=\-]{2,}\s*$/g, "").replace(/\[\^.+?\](\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "").replace(/\!\[(.*?)\][\[\(].*?[\]\)]/g, options.useImgAltText ? "$1" : "").replace(/\[([^\]]*?)\][\[\(].*?[\]\)]/g, options.replaceLinksWithURL ? "$2" : "$1").replace(/^(\n)?\s{0,3}>\s?/gm, "$1").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "").replace(/^(\n)?\s{0,}#{1,6}\s*( (.+))? +#+$|^(\n)?\s{0,}#{1,6}\s*( (.+))?$/gm, "$1$3$4$6").replace(/([\*]+)(\S)(.*?\S)??\1/g, "$2$3").replace(/(^|\W)([_]+)(\S)(.*?\S)??\2($|\W)/g, "$1$3$4$5").replace(/(`{3,})(.*?)\1/gm, "$2").replace(/`(.+?)`/g, "$1").replace(/~(.*?)~/g, "$1");
  } catch (e) {
    console.error(e);
    return md;
  }
  return output;
}

// utils/utils.ts
var import_obsidian = require("obsidian");
function getBasePath() {
  let adapter = this.app.vault.adapter;
  if (adapter instanceof import_obsidian.FileSystemAdapter) {
    return adapter.getBasePath();
  }
  return "~/";
}

// utils/multiselect.ts
function getMultiselectText(editor) {
  // Get all selections (including multiselect)
  const selections = editor.listSelections();
  
  if (!selections || selections.length === 0) {
    return "";
  }
  
  // If only one selection and it's empty (just cursor), return empty
  if (selections.length === 1 && selections[0].anchor.line === selections[0].head.line && selections[0].anchor.ch === selections[0].head.ch) {
    return "";
  }
  
  // Extract text from all selections and merge them
  const selectedTexts = [];
  
  for (const selection of selections) {
    // Determine the start and end positions of the selection
    const from = {
      line: Math.min(selection.anchor.line, selection.head.line),
      ch: selection.anchor.line === selection.head.line ? 
          Math.min(selection.anchor.ch, selection.head.ch) : 
          (selection.anchor.line < selection.head.line ? selection.anchor.ch : selection.head.ch)
    };
    const to = {
      line: Math.max(selection.anchor.line, selection.head.line),
      ch: selection.anchor.line === selection.head.line ? 
          Math.max(selection.anchor.ch, selection.head.ch) : 
          (selection.anchor.line > selection.head.line ? selection.anchor.ch : selection.head.ch)
    };
    
    // Get the selected text
    const selectedText = editor.getRange(from, to);
    if (selectedText.trim().length > 0) {
      selectedTexts.push(selectedText.trim());
    }
  }
  
  // Join all selected texts with a separator (space or period for natural speech flow)
  return selectedTexts.join(". ");
}

// Settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  customModelFilePath: "",
  customModelConfigFilePath: "",
  piperExecutableFilePath: "",
  shouldUseCustomModel: true,
  
  // Enhanced formatting removal settings
  removeHighlights: true,
  removeInserts: true,
  removeComments: true,
  removeAngleBrackets: true,
  removeParentheses: true,
  removeCurlyBraces: true,
  customWrappers: [],
  customRegexPattern: ""
};

var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    
    // Audio settings section
    containerEl.createEl("h2", { text: "Audio Settings" });
    this.addSettingToSelectPiperExecutablePath(containerEl);
    this.addSettingToSelectModelFilePath(containerEl);
    this.addSettingToSelectModelConfigFilePath(containerEl);
    
    // Formatting removal settings section
    containerEl.createEl("h2", { text: "Text Formatting Removal" });
    containerEl.createEl("p", { 
      text: "Configure which formatting elements should be removed from text before converting to speech.",
      cls: "setting-item-description"
    });
    
    this.addFormattingToggleSettings(containerEl);
    this.addCustomWrappersSettings(containerEl);
    this.addCustomRegexSettings(containerEl);
  }
  
  addFormattingToggleSettings(containerEl) {
    new import_obsidian2.Setting(containerEl)
      .setName("Remove highlights (==text==)")
      .setDesc("Remove highlight formatting before TTS conversion")
      .addToggle((component) => {
        component.setValue(this.plugin.settings.removeHighlights);
        component.onChange((value) => {
          this.plugin.settings.removeHighlights = value;
          this.plugin.saveSettings();
        });
      });
      
    new import_obsidian2.Setting(containerEl)
      .setName("Remove inserts (++text++)")
      .setDesc("Remove insert formatting before TTS conversion")
      .addToggle((component) => {
        component.setValue(this.plugin.settings.removeInserts);
        component.onChange((value) => {
          this.plugin.settings.removeInserts = value;
          this.plugin.saveSettings();
        });
      });
      
    new import_obsidian2.Setting(containerEl)
      .setName("Remove comments (%%text%%)")
      .setDesc("Remove comment blocks before TTS conversion")
      .addToggle((component) => {
        component.setValue(this.plugin.settings.removeComments);
        component.onChange((value) => {
          this.plugin.settings.removeComments = value;
          this.plugin.saveSettings();
        });
      });
      
    new import_obsidian2.Setting(containerEl)
      .setName("Remove angle brackets (<<text>>)")
      .setDesc("Remove angle bracket formatting before TTS conversion")
      .addToggle((component) => {
        component.setValue(this.plugin.settings.removeAngleBrackets);
        component.onChange((value) => {
          this.plugin.settings.removeAngleBrackets = value;
          this.plugin.saveSettings();
        });
      });
      
    new import_obsidian2.Setting(containerEl)
      .setName("Remove double parentheses ((text))")
      .setDesc("Remove double parentheses formatting before TTS conversion")
      .addToggle((component) => {
        component.setValue(this.plugin.settings.removeParentheses);
        component.onChange((value) => {
          this.plugin.settings.removeParentheses = value;
          this.plugin.saveSettings();
        });
      });
      
    new import_obsidian2.Setting(containerEl)
      .setName("Remove curly braces ({{text}})")
      .setDesc("Remove curly brace formatting before TTS conversion (excludes {{listen}} tags)")
      .addToggle((component) => {
        component.setValue(this.plugin.settings.removeCurlyBraces);
        component.onChange((value) => {
          this.plugin.settings.removeCurlyBraces = value;
          this.plugin.saveSettings();
        });
      });
  }
  
  addCustomWrappersSettings(containerEl) {
    const wrapperContainer = containerEl.createDiv();
    
    new import_obsidian2.Setting(wrapperContainer)
      .setName("Custom wrapper characters")
      .setDesc("Add custom characters that wrap text to be removed (e.g., ** for **bold**, ~~ for ~~strikethrough~~)")
      .addButton((button) => {
        button
          .setButtonText("Add custom wrapper")
          .setCta()
          .onClick(() => {
            this.plugin.settings.customWrappers.push("");
            this.plugin.saveSettings();
            this.display();
          });
      });
    
    // Display existing custom wrappers
    this.plugin.settings.customWrappers.forEach((wrapper, index) => {
      new import_obsidian2.Setting(wrapperContainer)
        .setName(`Custom wrapper ${index + 1}`)
        .addText((text) => {
          text.setPlaceholder("e.g., ** or ~~ or @@")
            .setValue(wrapper)
            .onChange((value) => {
              this.plugin.settings.customWrappers[index] = value;
              this.plugin.saveSettings();
            });
        })
        .addButton((button) => {
          button
            .setIcon("trash")
            .setTooltip("Remove this custom wrapper")
            .onClick(() => {
              this.plugin.settings.customWrappers.splice(index, 1);
              this.plugin.saveSettings();
              this.display();
            });
        });
    });
  }
  
  addCustomRegexSettings(containerEl) {
    new import_obsidian2.Setting(containerEl)
      .setName("Custom regex pattern")
      .setDesc("Advanced: Enter a custom regex pattern to remove specific text patterns. Use with caution!")
      .addTextArea((text) => {
        text.setPlaceholder("e.g., \\[\\[.*?\\]\\] to remove all wiki links")
          .setValue(this.plugin.settings.customRegexPattern)
          .onChange((value) => {
            this.plugin.settings.customRegexPattern = value;
            this.plugin.saveSettings();
          });
      });
      
    containerEl.createEl("p", { 
      text: "Examples: \\d{4}-\\d{2}-\\d{2} (removes dates), #\\w+ (removes hashtags), @\\w+ (removes mentions)",
      cls: "setting-item-description"
    });
  }
  
  addSettingToSelectModelFilePath(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Select custom model file").setDesc(`File that ends with .onnx`).addText((component) => {
      component.setDisabled(true);
      component.setValue(this.plugin.settings.customModelFilePath);
    }).addExtraButton((component) => {
      component.setIcon("folder-open");
      component.setTooltip("Select model");
      component.onClick(() => {
        electron.remote.dialog.showOpenDialog({
          properties: ["openFile"],
          title: "Select a model"
        }).then((result) => {
          if (result.canceled)
            return;
          this.plugin.settings.customModelFilePath = result.filePaths[0];
          this.plugin.saveSettings();
          this.display();
        });
      });
    });
  }
  addSettingToSelectModelConfigFilePath(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Select model config file").setDesc(`File that ends with .json`).addText((component) => {
      component.setDisabled(true);
      component.setValue(this.plugin.settings.customModelConfigFilePath);
    }).addExtraButton((component) => {
      component.setIcon("folder-open");
      component.setTooltip("Select model config");
      component.onClick(() => {
        electron.remote.dialog.showOpenDialog({
          properties: ["openFile"],
          title: "Select a model config"
        }).then((result) => {
          if (result.canceled)
            return;
          this.plugin.settings.customModelConfigFilePath = result.filePaths[0];
          this.plugin.saveSettings();
          this.display();
        });
      });
    });
  }
  addSettingsToChooseWhetherToUseCustomModelOrDefault(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Use custom model?").setDesc(`Turn this on if you want to use different voice model. Check this doc to understand more: DOC LINK`).addToggle((component) => {
      component.setValue(this.plugin.settings.shouldUseCustomModel);
      component.onChange((value) => {
        this.plugin.settings.shouldUseCustomModel = value;
        this.plugin.saveSettings();
        this.display();
      });
    });
  }
  addSettingToSelectPiperExecutablePath(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Select Piper executable file").setDesc(`This is required`).addText((component) => {
      component.setDisabled(true);
      component.setValue(this.plugin.settings.piperExecutableFilePath);
    }).addExtraButton((component) => {
      component.setIcon("folder-open");
      component.setTooltip("Select piper executable");
      component.onClick(() => {
        electron.remote.dialog.showOpenDialog({
          properties: ["openFile"],
          title: "Select piper executable"
        }).then((result) => {
          if (result.canceled)
            return;
          this.plugin.settings.piperExecutableFilePath = result.filePaths[0];
          this.plugin.saveSettings();
          this.display();
        });
      });
    });
  }
};

// main.ts
var ListenUp = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    
    // Register context menu for temporary audio playback (editor only)
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        // Only show the option if there's selected text in the editor
        const multiselectText = getMultiselectText(editor);
        if (multiselectText.length > 0) {
          menu.addItem((item) => {
            item
              .setTitle("🔊 Listen to selected text")
              .setIcon("audio-file")
              .onClick(() => {
                this.playSelectedTextTemporarily(editor);
              });
          });
        }
      })
    );

    // Register a global DOM contextmenu listener so the TTS option appears in ANY text selection context
    // (including read-only views such as spaced repetition windows). It will do nothing when no text is selected.
    this.registerDomEvent(document, "contextmenu", (evt) => {
      try {
        // Get selected text using the Selection API
        const sel = window.getSelection ? window.getSelection() : null;
        let selectedText = "";
        if (sel) {
          selectedText = sel.toString();
        }

        // If nothing selected, also check active element (inputs/textarea) for selected text
        if ((!selectedText || selectedText.trim().length === 0) && document.activeElement) {
          const ae = document.activeElement;
          try {
            if ((ae instanceof HTMLInputElement || ae instanceof HTMLTextAreaElement) && ae.selectionStart !== undefined) {
              const start = ae.selectionStart;
              const end = ae.selectionEnd;
              if (start !== end) {
                selectedText = ae.value.substring(start, end);
              }
            } else if (ae && ae.getAttribute && ae.getAttribute("contenteditable") === "true") {
              // contenteditable elements - use Selection API fallback
              selectedText = (window.getSelection ? window.getSelection().toString() : "") || "";
            }
          } catch (e) {
            // ignore
          }
        }

        if (!selectedText || selectedText.trim().length === 0) {
          // Do nothing if no selection (per user request)
          return;
        }

        // Normalize whitespace
        selectedText = selectedText.trim();
        // Build an Obsidian menu at cursor position that contains the TTS action
        const menu = new import_obsidian3.Menu(this.app);
        menu.addItem((item) => {
          item
            .setTitle("🔊 Listen to selected text")
            .setIcon("audio-file")
            .onClick(() => {
              // Use the new helper that accepts a plain string (applies formatting removal settings)
              this.playTextTemporarily(selectedText);
            });
        });
        // Show menu near the mouse click
        // Use coordinates from the event if available
        const x = evt.clientX || (evt.pageX || 0);
        const y = evt.clientY || (evt.pageY || 0);
        menu.showAtPosition({ x, y });
      } catch (error) {
        console.error("Context menu TTS handler error:", error);
      }
    });
    
    this.addCommand({
      id: "convert-text-to-speech",
      name: "Convert text to speech",
      editorCallback: async (editor, _) => {
        const notice = new import_obsidian3.Notice(
          "Converting the text to natural speech, please wait..",
          0
        );
        const basePath = getBasePath();
        const currentFile = this.app.workspace.getActiveFile();
        const audioFileName = (
          // @ts-ignore
          (currentFile == null ? void 0 : currentFile.name.replaceAll(" ", "-")) + "-" + this.getRandomNumber() + ".wav"
        );
        const piperLocation = (0, import_obsidian3.normalizePath)(this.settings.piperExecutableFilePath);
        let modelPath = (0, import_obsidian3.normalizePath)(basePath + "/" + DEFAULT_SETTINGS.customModelFilePath);
        let modelConfigPath = (0, import_obsidian3.normalizePath)(basePath + "/" + DEFAULT_SETTINGS.customModelConfigFilePath);
        const outputFilePath = (0, import_obsidian3.normalizePath)(basePath + "/" + audioFileName);
        modelPath = (0, import_obsidian3.normalizePath)(this.settings.customModelFilePath);
        modelConfigPath = (0, import_obsidian3.normalizePath)(this.settings.customModelConfigFilePath);
        const piperCommand = `"${piperLocation}" --model "${modelPath}" --config "${modelConfigPath}" --output_file "${outputFilePath}" --sentence_silence 0.5 --length_scale 1`;
        let textToConvertToAudio = editor.getValue();
        const regExMatch = textToConvertToAudio.match(
          /{{listen}}([\s\S]*?){{\/listen}}/g
        );
        
        // Enhanced multiselect support - get all selected text and merge it
        const multiselectText = getMultiselectText(editor);
        
        if (regExMatch !== null) {
          // If there are {{listen}} tags, use those
          textToConvertToAudio = regExMatch.join(", ").replaceAll(/{{listen}}|{{\/listen}}/g, "");
        } else if (multiselectText.length > 0) {
          // If there are selections (single or multi), use the merged selected text
          textToConvertToAudio = multiselectText;
        }
        // Otherwise, use the entire document content (existing behavior)
        
        // Create formatting options from settings
        const formattingOptions = {
          removeHighlights: this.settings.removeHighlights,
          removeInserts: this.settings.removeInserts,
          removeComments: this.settings.removeComments,
          removeAngleBrackets: this.settings.removeAngleBrackets,
          removeParentheses: this.settings.removeParentheses,
          removeCurlyBraces: this.settings.removeCurlyBraces,
          customWrappers: this.settings.customWrappers,
          customRegexPattern: this.settings.customRegexPattern
        };
        
        textToConvertToAudio = removeAllFormatting(
          textToConvertToAudio != null ? textToConvertToAudio : " ",
          formattingOptions
          // @ts-ignore
        ).replaceAll('"', '\\"');
        (0, import_child_process.exec)(
          `echo "${textToConvertToAudio}" | ${piperCommand}`,
          async (error) => {
            if (error) {
              console.error(`

error: ${error.message}`);
              notice.setMessage("Something went wrong. Please raise an issue on Github or Discord");
              return;
            }
            const markdownLink = `![[${audioFileName}]]`;
            
            // Get the current cursor position or the last selection position
            const selections = editor.listSelections();
            let insertPosition;
            
            if (selections && selections.length > 0) {
              // Find the last (bottom-most) selection to insert the audio link after it
              const lastSelection = selections.reduce((latest, current) => {
                const currentEnd = {
                  line: Math.max(current.anchor.line, current.head.line),
                  ch: current.anchor.line === current.head.line ? 
                      Math.max(current.anchor.ch, current.head.ch) : 
                      (current.anchor.line > current.head.line ? current.anchor.ch : current.head.ch)
                };
                
                const latestEnd = {
                  line: Math.max(latest.anchor.line, latest.head.line),
                  ch: latest.anchor.line === latest.head.line ? 
                      Math.max(latest.anchor.ch, latest.head.ch) : 
                      (latest.anchor.line > latest.head.line ? latest.anchor.ch : latest.head.ch)
                };
                
                return (currentEnd.line > latestEnd.line || 
                       (currentEnd.line === latestEnd.line && currentEnd.ch > latestEnd.ch)) ? 
                       current : latest;
              });
              
              insertPosition = {
                line: Math.max(lastSelection.anchor.line, lastSelection.head.line),
                ch: lastSelection.anchor.line === lastSelection.head.line ? 
                    Math.max(lastSelection.anchor.ch, lastSelection.head.ch) : 
                    (lastSelection.anchor.line > lastSelection.head.line ? lastSelection.anchor.ch : lastSelection.head.ch)
              };
            } else {
              // Fallback to current cursor position
              insertPosition = editor.getCursor("to");
            }

            // Insert the markdown link at the determined position
            editor.replaceRange(markdownLink, insertPosition);

            // Set cursor after the inserted link
            editor.setCursor({ 
              line: insertPosition.line, 
              ch: insertPosition.ch + markdownLink.length 
            });

            setTimeout(() => {
              notice.hide();
            }, 200);
          }
        );
      }
    });
    
    // Add command for temporary playback (can be assigned to hotkey)
    this.addCommand({
      id: "play-selected-text-temporarily",
      name: "Play selected text (temporary)",
      editorCallback: async (editor, _) => {
        const multiselectText = getMultiselectText(editor);
        if (multiselectText.length > 0) {
          await this.playSelectedTextTemporarily(editor);
        } else {
          new import_obsidian3.Notice("No text selected for playback");
        }
      }
    });
  }
  
  async playSelectedTextTemporarily(editor) {
    const notice = new import_obsidian3.Notice(
      "🔊 Playing selected text...",
      0
    );
    
    try {
      const basePath = getBasePath.call(this);
      const tempAudioFileName = `temp-audio-${this.getRandomNumber()}-${Date.now()}.wav`;
      const piperLocation = (0, import_obsidian3.normalizePath)(this.settings.piperExecutableFilePath);
      const modelPath = (0, import_obsidian3.normalizePath)(this.settings.customModelFilePath);
      const modelConfigPath = (0, import_obsidian3.normalizePath)(this.settings.customModelConfigFilePath);
      const tempOutputFilePath = (0, import_obsidian3.normalizePath)(basePath + "/" + tempAudioFileName);
      
      const piperCommand = `"${piperLocation}" --model "${modelPath}" --config "${modelConfigPath}" --output_file "${tempOutputFilePath}" --sentence_silence 0.5 --length_scale 1`;
      
      // Get and process the selected text with formatting options from settings
      let textToConvertToAudio = getMultiselectText(editor);
      
      const formattingOptions = {
        removeHighlights: this.settings.removeHighlights,
        removeInserts: this.settings.removeInserts,
        removeComments: this.settings.removeComments,
        removeAngleBrackets: this.settings.removeAngleBrackets,
        removeParentheses: this.settings.removeParentheses,
        removeCurlyBraces: this.settings.removeCurlyBraces,
        customWrappers: this.settings.customWrappers,
        customRegexPattern: this.settings.customRegexPattern
      };
      
      textToConvertToAudio = removeAllFormatting(
        textToConvertToAudio,
        formattingOptions
      ).replaceAll('"', '\\"');
      
      // Generate the temporary audio file
      (0, import_child_process.exec)(
        `echo "${textToConvertToAudio}" | ${piperCommand}`,
        async (error) => {
          if (error) {
            console.error(`TTS error: ${error.message}`);
            notice.setMessage("❌ Failed to generate audio");
            setTimeout(() => notice.hide(), 3000);
            return;
          }
          
          try {
            // Play the audio file
            await this.playAudioFile(tempOutputFilePath);
            notice.setMessage("✅ Audio playback completed");
            
            // Clean up the temporary file after a short delay
            setTimeout(() => {
              this.cleanupTempFile(tempOutputFilePath);
              notice.hide();
            }, 1000);
            
          } catch (playError) {
            console.error(`Audio playback error: ${playError.message}`);
            notice.setMessage("❌ Failed to play audio");
            setTimeout(() => {
              this.cleanupTempFile(tempOutputFilePath);
              notice.hide();
            }, 3000);
          }
        }
      );
      
    } catch (error) {
      console.error(`Temporary playback error: ${error.message}`);
      notice.setMessage("❌ Failed to process text for audio playback");
      setTimeout(() => notice.hide(), 3000);
    }
  }

  // New helper: play arbitrary text (string) temporarily — used by global context menu (non-editor selections)
  async playTextTemporarily(text) {
    const notice = new import_obsidian3.Notice(
      "🔊 Playing selected text...",
      0
    );
    try {
      if (!text || String(text).trim().length === 0) {
        notice.setMessage("No text selected for playback");
        setTimeout(() => notice.hide(), 1000);
        return;
      }

      const basePath = getBasePath.call(this);
      const tempAudioFileName = `temp-audio-${this.getRandomNumber()}-${Date.now()}.wav`;
      const piperLocation = (0, import_obsidian3.normalizePath)(this.settings.piperExecutableFilePath);
      const modelPath = (0, import_obsidian3.normalizePath)(this.settings.customModelFilePath);
      const modelConfigPath = (0, import_obsidian3.normalizePath)(this.settings.customModelConfigFilePath);
      const tempOutputFilePath = (0, import_obsidian3.normalizePath)(basePath + "/" + tempAudioFileName);

      const piperCommand = `"${piperLocation}" --model "${modelPath}" --config "${modelConfigPath}" --output_file "${tempOutputFilePath}" --sentence_silence 0.5 --length_scale 1`;

      const formattingOptions = {
        removeHighlights: this.settings.removeHighlights,
        removeInserts: this.settings.removeInserts,
        removeComments: this.settings.removeComments,
        removeAngleBrackets: this.settings.removeAngleBrackets,
        removeParentheses: this.settings.removeParentheses,
        removeCurlyBraces: this.settings.removeCurlyBraces,
        customWrappers: this.settings.customWrappers,
        customRegexPattern: this.settings.customRegexPattern
      };

      let textToConvertToAudio = removeAllFormatting(String(text), formattingOptions).replaceAll('"', '\\"');

      (0, import_child_process.exec)(
        `echo "${textToConvertToAudio}" | ${piperCommand}`,
        async (error) => {
          if (error) {
            console.error(`TTS error: ${error.message}`);
            notice.setMessage("❌ Failed to generate audio");
            setTimeout(() => notice.hide(), 3000);
            return;
          }

          try {
            await this.playAudioFile(tempOutputFilePath);
            notice.setMessage("✅ Audio playback completed");
            setTimeout(() => {
              this.cleanupTempFile(tempOutputFilePath);
              notice.hide();
            }, 1000);
          } catch (playError) {
            console.error(`Audio playback error: ${playError.message}`);
            notice.setMessage("❌ Failed to play audio");
            setTimeout(() => {
              this.cleanupTempFile(tempOutputFilePath);
              notice.hide();
            }, 3000);
          }
        }
      );
    } catch (err) {
      console.error("playTextTemporarily error:", err);
      notice.setMessage("❌ Failed to play selected text");
      setTimeout(() => notice.hide(), 2000);
    }
  }
  
  async playAudioFile(filePath) {
    return new Promise((resolve, reject) => {
      let playCommand;
      
      // Determine the appropriate audio player based on the platform
      const platform = import_os.platform();
      
      if (platform === 'win32') {
        // Windows - use built-in media player
        playCommand = `powershell -c "(New-Object Media.SoundPlayer '${filePath}').PlaySync()"`;
      } else if (platform === 'darwin') {
        // macOS - use afplay
        playCommand = `afplay "${filePath}"`;
      } else {
        // Linux - try multiple players
        playCommand = `paplay "${filePath}" || aplay "${filePath}" || ffplay -nodisp -autoexit "${filePath}"`;
      }
      
      (0, import_child_process.exec)(playCommand, (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }
  
  cleanupTempFile(filePath) {
    try {
      if (import_fs.existsSync(filePath)) {
        import_fs.unlinkSync(filePath);
        console.log(`Cleaned up temporary audio file: ${filePath}`);
      }
    } catch (error) {
      console.warn(`Failed to cleanup temporary file ${filePath}: ${error.message}`);
    }
  }
  async onunload() {
  }
  getRandomNumber(min = 1e4, max = 99999) {
    return Math.floor(Math.random() * (max - min) + min);
  }
  async loadSettings() {
    const data = await this.loadData() || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
  }
  /**
   * Save data to disk, stored in data.json in plugin folder
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

/* nosourcemap */
